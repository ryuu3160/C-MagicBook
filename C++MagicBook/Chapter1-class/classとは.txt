このテキストではクラスについての詳細な説明を書いていこうと思う
class.hとclass.cppを見ながら読むと理解しやすいと思う

C言語には構造体という物がある
構造体メンバには変数のみを入れることができる

C++のクラスでは、メンバにデータだけではなく、関数も含むことが出来る
拡張された構造体というイメージが分かりやすいと思う

クラス内のメンバ関数をcppで定義する時は、"型 クラス名::関数名(引数)"となる

"::"この演算子はスコープ解決演算子と言い、"::"の後に記述される内容(コンストラクタやメソッドなど)が
何処のクラスや名前空間(Chapter2-namespace参照)に所属するのかを明示的に記述する際に用いられる
C++ではいやというほど見ることになる演算子なので、覚えておくと良いだろう

class内に書かれている"private:"や"public:"はアクセス修飾子(指定子)と呼ばれ、メンバ変数やメンバ関数にアクセスできる範囲を指定することが出来る
"private"はその名の通り、クラス外からのアクセスを禁止する事が出来る
"public"はクラス外からのアクセスを許可することができる

他にも、"protected"という修飾子があり、これはサブクラスまでならアクセスを許可するというものである
これに関しては今の所は、そういうものもあるんだなぁ程度で良い

さて、次はコンストラクタとデストラクタだ
この2つのメンバ関数は、記述せずとも、オブジェクト生成時/解放時に自動的に生成される
加えて、この2つのメンバ関数には戻り値が存在しない※ただしvoid型ではなく型の指定をしない

コンストラクタに関して、class.hに記述してある、引数の無いPOS();は特に、デフォルトコンストラクタと呼ばれている
※C++では引数を省略した場合void型として扱われる←ここ重要

このサンプルコードで"POS();"と"POS(int x,int y);"という、同じ名前のコンストラクタが定義されている
これは関数のオーバーロードという機能により、同じ名前の関数でも、引数の違いで別の関数と認識するというものである
詳しくはChapter6-overloadで解説する

class.cppに、デストラクタの処理で、何もやることがないと書いてあるが、その理由を説明しよう
デストラクタは、オブジェクト解放時(returnやdestroy)に自動的に呼び出される関数である
このデストラクタでやりたい事は、主にメモリの解放であるため、現時点でのコードでは何もやることが無いのである
デストラクタで行う処理について、詳しいことはChapter3-new/deleteで解説する


メンバ関数の後端に"const"が付いているものについて詳しく説明していく
この"const"が付いた関数は、メンバ変数の値を書き換えないという意味である
もしも、constが付いた関数内でメンバ変数の値を書き換えようとした場合、ビルドエラーになる
メンバ変数へのアクセス(参照)は禁止されていないので、メンバ変数を書き換える事を想定していない関数には全てconstを付けるといいだろう
逆に、メンバ変数を書き換える事を想定している関数にはconstを付けてはならない
constを付ける利点として、一目でメンバ変数を書き換える可能性があるかどうかが分かる点である


次に、thisポインタについて説明しようと思う
これは、クラスオブジェクトのメンバにアクセスするときに使用するポインタだ
メンバ関数内ではthisポインタを省略して書くことも出来る
ここで気になってくるのが、thisポインタは何を指しているのか
簡潔に答えを言ってしまうと、
「thisポインタが指し示すものとは、メンバ関数を呼び出した"クラスオブジェクト"へのポインタなのである」
このthisポインタがあるおかげで、メンバ関数を呼び出したオブジェクトによって振る舞いが変化するのである


最後に、継承について説明する
継承とは既存のクラスを使用して新しいクラスを作成する機能のことだ
この機能を使用することで、既存のクラスのメンバを最初から持っている、新しいクラスを作成することができるようになる
この祭、継承元のクラス(既存のクラス)の事を、"基本クラス、基底クラス、ベースクラス、スーパークラス、親クラス"といった名前で呼ぶ
継承先のクラスの事は、"派生クラス、サブクラス、子クラス"などと呼ぶ
これ以降の説明では、継承元クラスを基底クラス、継承先クラスを派生クラスと呼ぶ

では、継承をする目的を説明する
継承の目的は既存のクラスを再利用してプログラミングを効率化することにある
例えばゲームで敵のクラスを作成する場合、大抵は敵の種類分のクラスを作成するだろう
その敵クラスのメンバの中には同じ意図のメンバが複数存在するはずだ(座標や、速度、HP、攻撃力などの変数や、ダメージ計算の関数など)
継承を使用しない場合は全てのクラスで同じメンバの宣言を行う必要がある
だが、継承を使用した場合、共通のメンバを持つ基底クラスを定義すれば、
そのクラスを継承するだけで継承先のクラスではそれらのメンバを宣言する必要がなくなる
このように複数のクラスで共通するメンバを１つのクラスにまとめることを汎化(はんか)という

継承についての書き方はclass.hとclass.cppで説明しているので、1つ注意点だけ記載しておく
基底クラスのメンバの内、privateになっているものは、派生クラスでは使用できない
使用しようとするとエラーになるので、private設定をする場合は、派生先で使用しないようにすること
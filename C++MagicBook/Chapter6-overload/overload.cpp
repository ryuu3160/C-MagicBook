//overload.cpp
#include "overload.h"
#include <stdlib.h>
#include <stdio.h>

//この章では関数のオーバーロードと演算子のオーバーロードについて解説する

//関数のオーバーロード
//関数のオーバーロードというものは、同じ名前の関数を複数定義できるというものだ

//関数のオーバーロードをよく使うのはコンストラクタである
//Chapter1のclass.hで書かれているコードを見ると、"POS"という名前の関数が2回定義されているのが分かる

//関数のオーバーロードには定義するときの条件がある
//その条件とは、"引数の構成(データ型や個数)が違う場合にのみ、同一関数名を定義できる"という事だ
//ここで注意したいのが、戻り値のデータ型は、この条件には含まれない

//以下が定義例である

//1つ目
void FUNC(int num)
{
	printf("1つ目の関数\nint:%d\n", num);
}

//2つ目
void FUNC(float num)
{
	printf("2つ目の関数\nfloat:%f\n", num);
}

//3つ目
void FUNC(int num1, float num2)
{
	printf("3つ目の関数\nint:%d\nfloat:%f\n", num1,num2);
}

void UseFUNC()
{
	FUNC(10);		//1つ目呼び出し
	FUNC(3.5f);		//2つ目呼び出し
	FUNC(10, 3.5f);	//3つ目呼び出し
}

//関数のオーバーロードは、"処理概要は同じだが、引数によって動きを少し変えたい"というときに便利になってくる


//演算子のオーバーロード
//C++において、+や-といった演算子は関数として扱う事が出来る
//つまり、これらの演算子を関数として定義して、クラス独自の処理を行わせることが出来るのだ

//C言語では、構造体同士の足し算や引き算は出来ない
//以下例
typedef struct
{
	int x;
	int y;
}s_POS;

void Use_sPos()
{
	s_POS pos1 = { 100,200 };
	s_POS pos2 = { 200,400 };
	s_POS pos3 = {0,0};

#if 0
	pos3 = pos1 + pos2;//エラー
#endif
}
//pos1とpos2を足して、pos3(300,600)という結果を出したいが、直接は足すことができないため、xとyを個別で足す必要がある

//C++において、このpos1とpos2を、+演算子を用いて直接足す事を可能にするのが演算子のオーバーロードというものだ
//overload.hと以下に例を記述する

//演算子のオーバーロードの定義
//operatorというキーワードの後ろに、演算子を記述する
//引数と戻り値は、演算子の種類や、何をどう作用させたいかによって変わってくる
OverPos OverPos::operator+(OverPos rhs)
{
	OverPos pos;

	pos.x = this->x + rhs.x;
	pos.y = this->y + rhs.y;

	return pos;
}

OverPos::OverPos()
{
	this->x = 0;
	this->y = 0;
}
void OverPos::SetPos(int x, int y)
{
	this->x = x;
	this->y = y;
}

//定義した演算子のオーバーライドの使用方法
void UseOverPos()
{
	OverPos pos1;
	OverPos pos2;
	OverPos pos3;
	OverPos pos4;

	pos1.SetPos(100, 200);
	pos2.SetPos(200, 400);

	//"+"演算子のオーバーロードにより可能になる
	pos3 = pos1 + pos2;

	//演算子のオーバーロードの呼び出し方2つ目
	//メンバ関数を使うパターンの呼び出し方
	pos4 = pos1.operator+(pos2);

	printf("pos3:\nx:%d,y:%d\n", pos3.x, pos3.y);
	printf("pos4:\nx:%d,y:%d\n", pos4.x, pos4.y);
}

//演算子のオーバーロードの利点は、演算子という記号を使うことで、処理が直観的で見やすくなるという点だ
//上記のような、複数のメンバ変数を足す処理みたいなものは、関数を作ってやるのではなく、演算子のオーバーロードを使った方が分かりやすいだろう

//この演算子のオーバーロードを使うにあたり注意するべきことは、"使う側にとって直観的にイメージできない演算子のオーバーロード"は控えるべきという事だ
//上記のOverPosクラスで例を挙げると、座標同士の足し引きは簡単にイメージできると思うが、座標の割り算と言われるとイメージしにくいと思う
//このように、その演算子によりもたらされる効果が、使い手にとってイメージしにくいものだと、逆に混乱を引き起こす事になってしまう

//演算子のオーバーロードを定義するときは、自分が使い手の気持ちになって、その演算子の効果を自然に受け入れられるかどうかを考えなければならない